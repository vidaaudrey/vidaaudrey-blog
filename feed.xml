<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.2">Jekyll</generator><link href="http://audreyli.me/feed.xml" rel="self" type="application/atom+xml" /><link href="http://audreyli.me/" rel="alternate" type="text/html" /><updated>2016-03-27T14:51:58-07:00</updated><id>http://audreyli.me/</id><title>vidaaudrey-blog</title><subtitle>Audrey Li&amp;#39;s personal blog</subtitle><author><name>Audrey Li</name><email>me@audreyli.me</email><uri>http://audreyli.me</uri></author><entry><title>Singles Day</title><link href="http://audreyli.me/general/2015/11/11/singles-day/" rel="alternate" type="text/html" title="Singles Day" /><published>2015-11-11T00:00:00-08:00</published><updated>2015-11-11T00:00:00-08:00</updated><id>http://audreyli.me/general/2015/11/11/singles-day</id><content type="html" xml:base="http://audreyli.me/general/2015/11/11/singles-day/">&lt;p&gt;As Beijing entering into middle night, the mostly amazing shopping spray day closes. &lt;/p&gt;

&lt;p&gt;91.2 Billion RMB! &lt;/p&gt;

&lt;p&gt;143 Billion USD of sales in a single day! It&#39;s a new chapter of history written with excitment, tears, pride, and happiness. It&#39;s a celebration and demonstration of a rising economy. It&#39;s a story of ups and downs, and mostly a story of wonders. &lt;/p&gt;


&lt;p&gt;As I sit in the classroom of MakerSquare San Francisco school in the early morning, I couldn&#39;t help writting a few words. The same time yesterday, I spent 1.5 hours shopping on TMall for my mom. The sales record reached 10 Billion RMB yesterday in the first 1.5 hours, which was the total amount of online sales in US during the Black Friday last year. There goes my little excitment knowing that I contributed something to that 1.5 hours&#39; sale.&lt;/p&gt; 


&lt;p&gt;Well, class starts in a few minutes. Here is a little funny closing video that captures the holiday:&lt;/p&gt; 

&lt;embed src=&quot;http://cloud.video.taobao.com/play/u/1095264730482/e/1/t/1/p/1/32081242.swf&quot; quality=&quot;high&quot; width=&quot;100%&quot; height=&quot;500&quot; align=&quot;middle&quot; allowScriptAccess=&quot;never&quot; allowFullScreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/embed&gt;</content><author><name>Audrey</name></author><summary>As Beijing entering into middle night, the mostly amazing shopping spray day closes. 91.2 Billion RMB! 143 Billion USD of sales in a single day! It&#39;s a new chapter of history written with excitment, tears, pride, and happiness. It&#39;s a celebration and demonstration of a rising economy. It&#39;s a story of ups and downs, and mostly a story of wonders.</summary></entry><entry><title>Relocating My Blog from Wordpress to Jekyll</title><link href="http://audreyli.me/jekyll/2015/09/27/relocating-my-blog-from-wordpress-to-Jekyll/" rel="alternate" type="text/html" title="Relocating My Blog from Wordpress to Jekyll" /><published>2015-09-27T00:00:00-07:00</published><updated>2015-09-27T00:00:00-07:00</updated><id>http://audreyli.me/jekyll/2015/09/27/relocating-my-blog-from-wordpress-to-Jekyll</id><content type="html" xml:base="http://audreyli.me/jekyll/2015/09/27/relocating-my-blog-from-wordpress-to-Jekyll/">&lt;p&gt;&lt;em&gt;A wise lady recently told me to write, always. I am not good at writing, but I am going to try anyway.&lt;/em&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;In this post, I am going to use different markup tags and format to show what styles are built in this new &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; blog. &lt;/p&gt;

&lt;p&gt;My last blog entry was on July 18th, which was about 2 months ago. In the past 2 months, I&amp;rsquo;ve spent some time trying to learn some front-end development skills and had two client projects. Although I love iOS, web development comes more handy and useful in the day-to-day life. And I feel fortunate that I&amp;rsquo;ll be attending Makersquare in early November for an intensive 3 months&amp;rsquo; training program. &lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Background&lt;/h3&gt;

&lt;p&gt;My precourse for the school will begin next week, so I spent last two days trying to relocate my blog from Wordpress to Jekyll, which I hope will give me more flexibility to do experiments on various front-end development topics. &lt;/p&gt;

&lt;h3&gt;Learnings from this relocation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Definitely love Jekyll. It&amp;rsquo;s much simpler than Wordpress and integration with Github is perfect. Moreover, I no longer need to pay for the hosting fee. &lt;/li&gt;
&lt;li&gt;Powerful template system. Don&amp;rsquo;t repeat yourself. &lt;/li&gt;
&lt;li&gt;Support for both HTML and markup. I never really used markup except for Github before. But I definitely will try to learn more. It&amp;rsquo;s much less cluttered than HTML. &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tools used&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SASS. Strictly speaking, SCSS, even I like SASS more, the conversion between existing CSS to SASS is much more work. &lt;/li&gt;
&lt;li&gt;Bootstrap. I&amp;rsquo;ve struggled whether I should use any framework in the beginning since my blog is very minimalistic and Jekyll comes with a great built-in support for a styling. But I went ahead and dropped Bootstrap in anyhow after some consideration for two reasons. First, it will greatly help speed up my development. Second, I&amp;rsquo;ll definitely need it for some future experiments. &lt;/li&gt;
&lt;li&gt;Yeoman Generator - Jekyllized. &lt;a href=&quot;https://github.com/robwierzbowski/generator-jekyllrb&quot;&gt;Generator-jekyllrb&lt;/a&gt; is the most popular Jekyll generator in Yeoman, and I&amp;rsquo;ve loved it at first, especially the support for Compass, CoffeeScript, HTML5 Boilerplate Template makes it very attractive for a beginner like me. But I had hard time getting it work properly. And somehow, I&amp;rsquo;ve developed a preference on Gulp over Grunt so I end up using &lt;a href=&quot;https://github.com/sondr3/generator-jekyllized&quot;&gt;Generator-jekyllized&lt;/a&gt;. I had to do some minor tweaks to make it work as the way I intended, and overall, I am pretty happy with Jekyllized. Other benefits of using Jekyllized:

&lt;ul&gt;
&lt;li&gt;Complete setup including layouts, config, 404, RSS Feed, posts and an example page. &lt;/li&gt;
&lt;li&gt;Support for related posts &lt;/li&gt;
&lt;li&gt;Syntax highlighting &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Cheatsheet for Styling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Jekyll has a directory &lt;code&gt;_posts&lt;/code&gt; which contains all the blog posts. &lt;/li&gt;
&lt;li&gt;Styles:

&lt;ul&gt;
&lt;li&gt; &lt;sup&gt;superscript:&lt;/sup&gt; &lt;code&gt;^superscript&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; &lt;u&gt;underline&lt;/u&gt;: &lt;code&gt;_underline_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; &lt;mark&gt;highlight&lt;/mark&gt;: &lt;code&gt;==highlight==&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;** bold **:  &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;* italicize *:  &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Abbreviations, like &lt;abbr title=&quot;HyperText Markup Language&quot;&gt;HTML&lt;/abbr&gt; use&lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, with an optional &lt;code&gt;title&lt;/code&gt; attribute for the full phrase.&lt;/li&gt;
&lt;li&gt;Citations, like &lt;cite&gt;&amp;mdash; Mark otto&lt;/cite&gt; uses &lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Deleted&lt;/del&gt; uses &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; and &lt;ins&gt;inserted&lt;/ins&gt; text: &lt;code&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Superscript &lt;sup&gt;text&lt;/sup&gt; uses &lt;code&gt;&amp;lt;sup&amp;gt;&lt;/code&gt; and subscript &lt;sub&gt;text&lt;/sub&gt; uses &lt;code&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt; Winter is coming&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Winter is coming. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;syntax highlighting &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;console.log(&amp;#39;Hello, this is Audrey&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;Hallo! Hello! &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://25.media.tumblr.com/tumblr_m79ecda9Q61qzex9io1_1280.jpg&quot; alt=&quot;Hello, world&quot;&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/vidaaudrey/d5a1ad6bb4b0d61c8a01.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><summary>A wise lady recently told me to write, always. I am not good at writing, but I am going to try anyway.



In this post, I am going to use different markup tags and format to show what styles are built in this new Jekyll blog. 

My last blog entry was on July 18th, which was about 2 months ago. In the past 2 months, I&amp;rsquo;ve spent some time trying to learn some front-end development skills and had two client projects. Although I love iOS, web development comes more handy and useful in the day-to-day life. And I feel fortunate that I&amp;rsquo;ll be attending Makersquare in early November for an intensive 3 months&amp;rsquo; training program. 



Background

My precourse for the school will begin next week, so I spent last two days trying to relocate my blog from Wordpress to Jekyll, which I hope will give me more flexibility to do experiments on various front-end development topics. 

Learnings from this relocation


Definitely love Jekyll. It&amp;rsquo;s much simpler than Wordpress and integration with Github is perfect. Moreover, I no longer need to pay for the hosting fee. 
Powerful template system. Don&amp;rsquo;t repeat yourself. 
Support for both HTML and markup. I never really used markup except for Github before. But I definitely will try to learn more. It&amp;rsquo;s much less cluttered than HTML. 


Tools used


SASS. Strictly speaking, SCSS, even I like SASS more, the conversion between existing CSS to SASS is much more work. 
Bootstrap. I&amp;rsquo;ve struggled whether I should use any framework in the beginning since my blog is very minimalistic and Jekyll comes with a great built-in support for a styling. But I went ahead and dropped Bootstrap in anyhow after some consideration for two reasons. First, it will greatly help speed up my development. Second, I&amp;rsquo;ll definitely need it for some future experiments. 
Yeoman Generator - Jekyllized. Generator-jekyllrb is the most popular Jekyll generator in Yeoman, and I&amp;rsquo;ve loved it at first, especially the support for Compass, CoffeeScript, HTML5 Boilerplate Template makes it very attractive for a beginner like me. But I had hard time getting it work properly. And somehow, I&amp;rsquo;ve developed a preference on Gulp over Grunt so I end up using Generator-jekyllized. I had to do some minor tweaks to make it work as the way I intended, and overall, I am pretty happy with Jekyllized. Other benefits of using Jekyllized:


Complete setup including layouts, config, 404, RSS Feed, posts and an example page. 
Support for related posts 
Syntax highlighting 



Cheatsheet for Styling


Jekyll has a directory _posts which contains all the blog posts. 
Styles:


 superscript: ^superscript
 underline: _underline_
 highlight: ==highlight== 
** bold **:  &amp;lt;strong&amp;gt;.
* italicize *:  &amp;lt;em&amp;gt;.
Abbreviations, like HTML use&amp;lt;abbr&amp;gt;, with an optional title attribute for the full phrase.
Citations, like &amp;mdash; Mark otto uses &amp;lt;cite&amp;gt;.
Deleted uses &amp;lt;del&amp;gt; and inserted text: &amp;lt;ins&amp;gt;.
Superscript text uses &amp;lt;sup&amp;gt; and subscript text uses &amp;lt;sub&amp;gt;.
&amp;gt; Winter is coming




Winter is coming. 



syntax highlighting 


console.log(&amp;#39;Hello, this is Audrey&amp;#39;);

Hallo! Hello!</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 21: Interpretor</title><link href="http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-21-interpretor/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 21: Interpretor" /><published>2015-07-18T00:00:00-07:00</published><updated>2015-07-18T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-21-interpretor</id><content type="html" xml:base="http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-21-interpretor/">&lt;p&gt;An interpreter translate our plain language expression into information and find out what we need. Here we have a  Unit Interpretor (Conversion Context) who does very diverse interpretation jobs.
&amp;lt;!&amp;ndash;more&amp;ndash;&amp;gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;enum UnitType: String {
    case Gallon = &amp;quot;Gallon&amp;quot;
    case Pint = &amp;quot;Pint&amp;quot;
    case Cup = &amp;quot;Cup&amp;quot;
    case USD = &amp;quot;USD&amp;quot;
    case RMB = &amp;quot;RMB&amp;quot;
    case EURO = &amp;quot;EURO&amp;quot;
    case Meter = &amp;quot;Meter&amp;quot;
    case Unkonwn = &amp;quot;Unknown&amp;quot;
    init(str: String) {
        switch str {
            case &amp;quot;Gallon&amp;quot;, &amp;quot;Gallons&amp;quot;, &amp;quot;gallons&amp;quot;: self = .Gallon
            case &amp;quot;Pint&amp;quot;, &amp;quot;Pints&amp;quot;, &amp;quot;pints&amp;quot;: self = .Pint
            case &amp;quot;Cup&amp;quot;, &amp;quot;Cups&amp;quot;, &amp;quot;cups&amp;quot;: self = .Cup
            case &amp;quot;USD&amp;quot;, &amp;quot;usd&amp;quot;, &amp;quot;Usd&amp;quot;: self = .USD
            case &amp;quot;EURO&amp;quot;, &amp;quot;euro&amp;quot;, &amp;quot;Euro&amp;quot;: self = .EURO
            case &amp;quot;RMB&amp;quot;, &amp;quot;rmb&amp;quot;, &amp;quot;Rmb&amp;quot;: self = .RMB
        default: self = .Unkonwn
        }
    }
}

protocol Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double
}
class Gallon: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .Gallon: return quantity
        case .Pint: return quantity * 8
        case .Cup: return quantity * 16
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1 // just saying it&amp;#39;s a wrong number
        }
    }
}
class Pint: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .Gallon: return quantity * 0.125
        case .Pint: return quantity
        case .Cup: return quantity * 2
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
        
    }
}
class USD: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .USD: return quantity
        case .EURO: return quantity * 0.92
        case .RMB: return quantity * 6.21
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
        
    }
}

class RMB: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {

        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .USD: return quantity * 0.16
        case .EURO: return quantity * 0.15
        case .RMB: return quantity
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
    }
}

struct AppConfig {
    static let AppName = &amp;quot;interpretor&amp;quot;
}
// The context to translate a sentence into related command and get the result.
class ConversionContext {
    static let sharedInstance = ConversionContext()
    private func getTargetQuantity(fromConversion: String, toConversion: String, quantity: Double) -&amp;gt; Double {
        if fromConversion != &amp;quot;&amp;quot; {
            let classStr = UnitType(str: fromConversion).rawValue
            guard let anyObjecType : AnyObject.Type = NSClassFromString(&amp;quot;\(AppConfig.AppName).\(classStr)&amp;quot;)
                else {
                    if classStr == &amp;quot;EURO&amp;quot; || classStr == &amp;quot;Cup&amp;quot; {
                        return -1
                    } else {
                        return -3
                    }
            }
            let nsObjecType : NSObject.Type = anyObjecType as! NSObject.Type
            
            guard let object = nsObjecType() as? Expression else {return -4 }
            return  object.getUnit(quantity, targetUnit: toConversion)
        
        }
        return -2
    }
    func getConversionFromInput(input:String) -&amp;gt; String {
        let partsOfQues = input.componentsSeparatedByString(&amp;quot; &amp;quot;)
        let fromConversion = partsOfQues[1]
        let toConversion = partsOfQues[3]
        let quantity = Double(partsOfQues[0])!
        
        let targetQuantity = getTargetQuantity(fromConversion, toConversion: toConversion, quantity: quantity)
        switch targetQuantity {
        case -1: return &amp;quot;Currently we only support conversion from RMB, USD, Gallon and Pint. \(fromConversion) is not supported&amp;quot;
        case -3: return &amp;quot;We can&amp;#39;t recognize your input yet. Try something like RMB, rmb, Gallon, Gallons...&amp;quot;
        case -2: return &amp;quot;Sorry, we couldn&amp;#39;t identify the source conversion. Try something like [ 10 Gallons to Pints ]&amp;quot;
        case -4: return &amp;quot;Couldn&amp;#39;t convert. The object we created doesn&amp;#39;t conform with Expression protocol&amp;quot;
        case let x where x &amp;gt;= 0 :  return &amp;quot;\(partsOfQues[0]) \(partsOfQues[1]) equals \(targetQuantity) \(partsOfQues[3])&amp;quot;
        default: return &amp;quot;Some other unknow error happened &amp;quot;
        }
    }
}

func getOutput(input: String) -&amp;gt; String {
    print(&amp;quot;Getting user input:[ \(input) ]&amp;quot;)
    let context = ConversionContext.sharedInstance
    return context.getConversionFromInput(input)
}

// Testing. User inputs a sentence and the conversionContext will translate it
let userInput = [
    &amp;quot;10 Gallons is Pints&amp;quot;,
    &amp;quot;231 Gallo is Pints&amp;quot;,
    &amp;quot;32.11 Pints in Gallon&amp;quot;,
    &amp;quot;2001.99 USD to RMB&amp;quot;,
    &amp;quot;984.2323 rmb in EURO&amp;quot;,
    &amp;quot;23 Euro in RMB&amp;quot;
]
userInput.map{ print(&amp;quot;Output: [ \(getOutput($0)) ] \n&amp;quot;) }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/interpretor.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1086&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/interpretor.png&quot; alt=&quot;interpretor&quot; width=&quot;693&quot; height=&quot;290&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Design Pattern" /><category term="Interpretor" /><category term="Swift" /><summary>An interpreter translate our plain language expression into information and find out what we need. Here we have a  Unit Interpretor (Conversion Context) who does very diverse interpretation jobs.
&amp;lt;!&amp;ndash;more&amp;ndash;&amp;gt;

enum UnitType: String {
    case Gallon = &amp;quot;Gallon&amp;quot;
    case Pint = &amp;quot;Pint&amp;quot;
    case Cup = &amp;quot;Cup&amp;quot;
    case USD = &amp;quot;USD&amp;quot;
    case RMB = &amp;quot;RMB&amp;quot;
    case EURO = &amp;quot;EURO&amp;quot;
    case Meter = &amp;quot;Meter&amp;quot;
    case Unkonwn = &amp;quot;Unknown&amp;quot;
    init(str: String) {
        switch str {
            case &amp;quot;Gallon&amp;quot;, &amp;quot;Gallons&amp;quot;, &amp;quot;gallons&amp;quot;: self = .Gallon
            case &amp;quot;Pint&amp;quot;, &amp;quot;Pints&amp;quot;, &amp;quot;pints&amp;quot;: self = .Pint
            case &amp;quot;Cup&amp;quot;, &amp;quot;Cups&amp;quot;, &amp;quot;cups&amp;quot;: self = .Cup
            case &amp;quot;USD&amp;quot;, &amp;quot;usd&amp;quot;, &amp;quot;Usd&amp;quot;: self = .USD
            case &amp;quot;EURO&amp;quot;, &amp;quot;euro&amp;quot;, &amp;quot;Euro&amp;quot;: self = .EURO
            case &amp;quot;RMB&amp;quot;, &amp;quot;rmb&amp;quot;, &amp;quot;Rmb&amp;quot;: self = .RMB
        default: self = .Unkonwn
        }
    }
}

protocol Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double
}
class Gallon: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .Gallon: return quantity
        case .Pint: return quantity * 8
        case .Cup: return quantity * 16
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1 // just saying it&amp;#39;s a wrong number
        }
    }
}
class Pint: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .Gallon: return quantity * 0.125
        case .Pint: return quantity
        case .Cup: return quantity * 2
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
        
    }
}
class USD: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {
        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .USD: return quantity
        case .EURO: return quantity * 0.92
        case .RMB: return quantity * 6.21
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
        
    }
}

class RMB: NSObject, Expression {
    func getUnit(quantity: Double, targetUnit: String) -&amp;gt; Double {

        let targetUnitType = UnitType(str: targetUnit)
        switch targetUnitType {
        case .USD: return quantity * 0.16
        case .EURO: return quantity * 0.15
        case .RMB: return quantity
        default:
            print(&amp;quot;conversion not supported&amp;quot;)
            return -1
        }
    }
}

struct AppConfig {
    static let AppName = &amp;quot;interpretor&amp;quot;
}
// The context to translate a sentence into related command and get the result.
class ConversionContext {
    static let sharedInstance = ConversionContext()
    private func getTargetQuantity(fromConversion: String, toConversion: String, quantity: Double) -&amp;gt; Double {
        if fromConversion != &amp;quot;&amp;quot; {
            let classStr = UnitType(str: fromConversion).rawValue
            guard let anyObjecType : AnyObject.Type = NSClassFromString(&amp;quot;\(AppConfig.AppName).\(classStr)&amp;quot;)
                else {
                    if classStr == &amp;quot;EURO&amp;quot; || classStr == &amp;quot;Cup&amp;quot; {
                        return -1
                    } else {
                        return -3
                    }
            }
            let nsObjecType : NSObject.Type = anyObjecType as! NSObject.Type
            
            guard let object = nsObjecType() as? Expression else {return -4 }
            return  object.getUnit(quantity, targetUnit: toConversion)
        
        }
        return -2
    }
    func getConversionFromInput(input:String) -&amp;gt; String {
        let partsOfQues = input.componentsSeparatedByString(&amp;quot; &amp;quot;)
        let fromConversion = partsOfQues[1]
        let toConversion = partsOfQues[3]
        let quantity = Double(partsOfQues[0])!
        
        let targetQuantity = getTargetQuantity(fromConversion, toConversion: toConversion, quantity: quantity)
        switch targetQuantity {
        case -1: return &amp;quot;Currently we only support conversion from RMB, USD, Gallon and Pint. \(fromConversion) is not supported&amp;quot;
        case -3: return &amp;quot;We can&amp;#39;t recognize your input yet. Try something like RMB, rmb, Gallon, Gallons...&amp;quot;
        case -2: return &amp;quot;Sorry, we couldn&amp;#39;t identify the source conversion. Try something like [ 10 Gallons to Pints ]&amp;quot;
        case -4: return &amp;quot;Couldn&amp;#39;t convert. The object we created doesn&amp;#39;t conform with Expression protocol&amp;quot;
        case let x where x &amp;gt;= 0 :  return &amp;quot;\(partsOfQues[0]) \(partsOfQues[1]) equals \(targetQuantity) \(partsOfQues[3])&amp;quot;
        default: return &amp;quot;Some other unknow error happened &amp;quot;
        }
    }
}

func getOutput(input: String) -&amp;gt; String {
    print(&amp;quot;Getting user input:[ \(input) ]&amp;quot;)
    let context = ConversionContext.sharedInstance
    return context.getConversionFromInput(input)
}

// Testing. User inputs a sentence and the conversionContext will translate it
let userInput = [
    &amp;quot;10 Gallons is Pints&amp;quot;,
    &amp;quot;231 Gallo is Pints&amp;quot;,
    &amp;quot;32.11 Pints in Gallon&amp;quot;,
    &amp;quot;2001.99 USD to RMB&amp;quot;,
    &amp;quot;984.2323 rmb in EURO&amp;quot;,
    &amp;quot;23 Euro in RMB&amp;quot;
]
userInput.map{ print(&amp;quot;Output: [ \(getOutput($0)) ]  &amp;quot;) }</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 20: Mediator</title><link href="http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-20-mediator/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 20: Mediator" /><published>2015-07-18T00:00:00-07:00</published><updated>2015-07-18T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-20-mediator</id><content type="html" xml:base="http://audreyli.me/2015/07/18/a-design-pattern-story-in-swift-chapter-20-mediator/">&lt;div class=&quot;page&quot; title=&quot;Page 414&quot;&gt;
  &lt;div class=&quot;layoutArea&quot;&gt;
    &lt;div class=&quot;column&quot;&gt;
      &lt;p&gt;
        &lt;span&gt; Artists paint, musicians compose, different jobs for different pros.  It&amp;#8217;s not easy for a person to find a pro directly to do a job without some sort of agent in the middle, and even harder for a pro to find a client among all the people.  A command mediator (aka. command dispatch center) takes all the burden away. It can process task according to the task requirement such as:&lt;/span&gt;
      &lt;/p&gt;
      
      &lt;ul&gt;
        &lt;li class=&quot;p1&quot;&gt;
          Group task will be sent to all the pros who can do the jobs
        &lt;/li&gt;
        &lt;li class=&quot;p1&quot;&gt;
          Normal task will be sent to the appropriate pros and get their quotations
        &lt;/li&gt;
        &lt;li class=&quot;p1&quot;&gt;
          Once the user has chosen the pro based on the quotations, the mediator will send the task to the chosen pro
        &lt;/li&gt;
        &lt;li class=&quot;p1&quot;&gt;
          Upon getting the work back from the pro, the mediator will send the work to the customer for confirmation
        &lt;/li&gt;
      &lt;/ul&gt;
      
      &lt;p&gt;
        The mediator pattern simplifies peer-to-peer communication between objects by introducing a mediator object that acts as a communications broker between the objects. Instead of having to keep track of and communicate with of all of its peers individually, an object just deals with the mediator.  &lt;em&gt;&lt;a href=&quot;http://www.apress.com/9781484203958&quot;&gt;Design Pattern in Swift&lt;/a&gt;&lt;/em&gt;
      &lt;/p&gt;
      
      
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;typealias CommandBlock = CommandPeer -&amp;gt; Any
enum ProType: String {
    case Artist = &amp;quot;Artist&amp;quot;
    case Musician = &amp;quot;Musician&amp;quot;
    case PartyPlanner = &amp;quot;Party Planner&amp;quot;
    case Other = &amp;quot;Other skills&amp;quot;
    case None = &amp;quot;No registered skills&amp;quot;
}
enum TaskStatus: String {
    case S0_Created = &amp;quot;Task Created&amp;quot;
    case S1_Submited = &amp;quot;Task Submitted&amp;quot;
    case S2_BroadCasted = &amp;quot;Task sent to pros&amp;quot;
    case S3_QuoteGathered = &amp;quot;Gathered quotes from pros&amp;quot;
    case S4_ProChosen = &amp;quot;Customer has chosen the pro to work with&amp;quot;
    case S5_SendToPro = &amp;quot;Task Center has sent the task to the pro&amp;quot;
    case S6_ProFinished = &amp;quot;Pro has finished the task&amp;quot;
    case S7_CustomConfirmWork = &amp;quot;Customer has confirmed the finished work&amp;quot;
    case Unknown = &amp;quot;Some unknown state&amp;quot;
}
// To make it simply, a customer and a pro are both command peers. They can initiate a task as a customer or finish a task as a pro.
protocol CommandPeer: CustomStringConvertible {
    var name:String { get }
    var tasks:[Task] { get set }
    var works:[Task] { get set }
    var isPro: Bool { get }
    var proType: ProType { get }

    func choosePro(var task: Task) -&amp;gt; Task
    func confirmWork(var task: Task) -&amp;gt; Task
    func submitQuote(task: Task) -&amp;gt; (name: String, price: Int, message: String)
    func finishTask(var task: Task) -&amp;gt; (task:Task, result: Any?)
}

// All that is needed to make a task a command, leaving for possibilities of different tasks and different task mediators.  If I use class implementation, the commandMediator just need to use the command protocol to talk, instead of the concrete task. But I used struct for concret task. As a result, the mediator is coupled with the task struct implementation.
protocol Command {
    var id: Int { get }
    var name: String { get }
    var proType: ProType { get }
    var isGroupTask: Bool { get set }
    var startBy:String { get set }
    var finishedBy: String { get set }
    var status: TaskStatus { get set }
    var quotes: [(name:String, price: Int, message: String)] { get set }
    var function:CommandBlock { get }
    func execute(peer: CommandPeer) -&amp;gt; Any
}

// commandMediator is kind of a task dispatch center. When the center receives tasks, it will look at the task configuration:
// * Group task -&amp;gt; Send to every registered pro who can do the task and get the work back 
// * Regular task  -&amp;gt; Check status of the task
// *** - Submited -&amp;gt; Send the task to the pros who can do the task and get their quotation
// *** - ProChosen -&amp;gt; Send the task to the chosen pros and get the final work, then send the work to the customer for confirmation
// For simplicity reason, a lof of things are left behind, such as what if the customer did not approve the work? Can I always expect work being returned from a pro? Can the pro be more proactive and submit their work at their own time? How do we track payment, can we keep only one copy of the task... Well, too many cases @_@
class CommandMediator {
    private var peers = [String:CommandPeer]()

    func registerPeer(peer:CommandPeer) {
        peers[peer.name] = peer
    }

    func unregisterPeer(peer:CommandPeer) {
        peers.removeValueForKey(peer.name)
    }
    // the core control logic, evaluate the task configuration and process accordingly.
    func dispatchCommand(caller:CommandPeer, task:Task) -&amp;gt; Any? {
        var result: Any?
        // this task will be execute by everyone who can do the work
        if task.isGroupTask {
            result = sendTaskToChosenProAndGetWork(caller, task: task, isGroupTask: true)
        } else {
            switch task.status {
            case .S1_Submited: result = sendTaskAndGatherQuotes(caller, task: task)
            case .S4_ProChosen: result = sendTaskToChosenProAndGetWork(caller, task: task)
            case .Unknown:  print(&amp;quot;Something unknow, check the status&amp;quot;)
            default: print(&amp;quot;do nothing, check later.....!&amp;quot;)
            }
        }
        return result
    }

    private func sendTaskAndGatherQuotes(caller: CommandPeer, var task: Task) -&amp;gt; Task {
        var quotes:[(name: String, price: Int, message: String)] = []
        for peer in peers.values {
            if (peer.name != caller.name) &amp;amp;&amp;amp; peer.isPro &amp;amp;&amp;amp; (peer.proType == task.proType) {
                quotes.append(peer.submitQuote(task))
            }
        }
        task.quotes = quotes
        task.status = TaskStatus.S3_QuoteGathered
        return task
    }
    private func sendTaskToChosenProAndGetWork(caller: CommandPeer, var task: Task, isGroupTask: Bool = false) -&amp;gt; (task:Task, result: Any?) {
        var fullResult:(Task, Any?) = (task, nil)
       // task.status = TaskStatus.S6_ProFinished
        var groupResult:[Any?] = []

        var groupNames:String = &amp;quot;&amp;quot;
         if !isGroupTask {
            let choosenProName = task.quotes[0].name
            for peer in peers.values {
                if peer.name == choosenProName {
                    fullResult = peer.finishTask(task)
                }
            }
         } else {
             for peer in peers.values {
                if (peer.name != caller.name) &amp;amp;&amp;amp; peer.isPro &amp;amp;&amp;amp; (peer.proType == task.proType) {
                    groupResult.append(peer.finishTask(task).result)
                    groupNames += &amp;quot;\(peer.name) , &amp;quot;
                }
            }
        }
        if groupResult.count &amp;gt; 0 {
            task.finishedBy = groupNames
            fullResult = (task, groupResult)
        }
        return fullResult
    }
}


func ==(lhs: Task, rhs: Task) -&amp;gt; Bool {
    return lhs.id == rhs.id
}

// Command implementation as Task
struct Task: Command, CustomStringConvertible {
    static var idCount = 1
    let id: Int
    let name: String
    var price: Int
    let function: CommandBlock
    let proType: ProType
    var finishedBy: String = &amp;quot;&amp;quot;
    var startBy: String = &amp;quot;&amp;quot;
    var isGroupTask: Bool
    var quotes: [(name:String, price: Int, message: String)] = []
    var status: TaskStatus { didSet { print(status.rawValue) } } 
    var description: String {
        return &amp;quot;\nCurrent Task Info: #\(id)\n --name: \(name) - \(proType.rawValue) job\n --started by: \(startBy) \n --finished by: \(finishedBy)\n --current status: \(status.rawValue)\n --quotations: \(quotes) \n&amp;quot;
    }

    init(name: String,price: Int, proType: ProType = .Artist, isGroupTask:Bool = false, function: CommandBlock){
        self.id = Task.idCount++
        self.name = name
        self.function = function
        self.proType = proType
        self.status = .S0_Created
        self.price = price
        self.isGroupTask = isGroupTask
    }
    func execute(peer: CommandPeer) -&amp;gt; Any {
        if peer.proType == self.proType {
            print(&amp;quot;Passing pro \(peer.name) the job...&amp;quot;)
            return function(peer)
        } else {
            return &amp;quot;Got no work from pro&amp;quot;
        }
    }

}
// CommandPeer implementation as a User, who can be a customer and a pro at the same time
class User: CommandPeer {
    var name: String
    let mediator: CommandMediator
    var tasks:[Task]
    var works:[Task]
    var isPro: Bool = true
    var proType: ProType
    var description: String {
        return &amp;quot;\(name) - \(proType.rawValue)\nTasks: \(tasks.map{$0.name}).  Works:\(works.map{$0.name})\n&amp;quot;
    }
    init(name: String, mediator: CommandMediator, isPro: Bool = true, proType: ProType = .None){
        self.name = name
        self.mediator = mediator
        tasks = []
        works = []
        self.isPro = isPro
        self.proType = proType
        mediator.registerPeer(self)
    }

    func sendTaskToGroupAndGetFinalWork(var task: Task) -&amp;gt; (task: Task, result: Any?){
        task.isGroupTask = true
        tasks.append(task)
        return mediator.dispatchCommand(self, task: task) as! (Task, Any?)
    }
    func sendTaskAndGetTaskWithQuotes(var task: Task) -&amp;gt; Task {
        task.startBy = name
        task.status = TaskStatus.S1_Submited
        tasks.append(task)
        return mediator.dispatchCommand(self, task: task) as! Task
    }

    func choseProAndGetFinalWork(var task: Task) -&amp;gt; (task: Task, result: Any?){
        task.status = TaskStatus.S4_ProChosen
        return mediator.dispatchCommand(self, task: task) as! (Task, Any?)
    }

    // function for customer: choose pro and confirm work. Mediator only sends task back if there is at least one quotation.
    func choosePro(var task: Task) -&amp;gt; Task{
        // assume customer is business, only randomly choose one quote
        let index = arc4random_uniform(UInt32(task.quotes.count))
        task.quotes = [task.quotes[Int(index)]]
        print(&amp;quot;Choose the pro\(task.quotes[0])&amp;quot;)
        task.status = TaskStatus.S4_ProChosen
        task.finishedBy = task.quotes[0].name
        return task
    }

    func confirmWork(var task: Task) -&amp;gt; Task{
        let index = tasks.indexOf {$0.id == task.id}
        task.status = .S7_CustomConfirmWork
        if index != nil {
            tasks[index!] = task
        }
        return task
    }

    // function for pro: submit quotes and finish task
    func submitQuote(task: Task) -&amp;gt; (name: String, price: Int, message: String) {
        let quote = task.price * (Int(arc4random_uniform(3)) + 1)
        let message = &amp;quot;Some random message for the customer: choose me...&amp;quot;
        return (name, quote, message)
    }

    // let&amp;#39;s assume a pro always finishes the job and give back the result now. Deal with bad pros later
    func finishTask(var task: Task) -&amp;gt; (task:Task, result: Any?){
        let result = task.execute(self)
        task.finishedBy = name
        task.status = TaskStatus.S6_ProFinished
        self.works.append(task)
        return (task, result)
    }

}

// Testing. Create some tasks and users
let partyTask = Task(name: &amp;quot;Host a Party of the Century&amp;quot;, price: 2000000, proType: .PartyPlanner) { peer in
    print(&amp;quot;\(peer.name) is doing the job&amp;quot;)
    print(&amp;quot;Inviting people...&amp;quot;)
    return &amp;quot;Final work: the greatest party ever...&amp;quot;
}
let partyTask1 = Task(name: &amp;quot;Host a Party of the Next Century&amp;quot;, price: 2220000, proType: .PartyPlanner) { peer in
    print(&amp;quot;\(peer.name) is doing the job&amp;quot;)
    print(&amp;quot;Inviting people...&amp;quot;)
    return &amp;quot;Final work: the greatest party ever....&amp;quot;
}
let musicTask = Task(name: &amp;quot;Write A Mountain-Moving Song&amp;quot;, price: 80000000, proType: .Musician) { peer in
    print(&amp;quot;\(peer.name) is doing the job...&amp;quot;)
    print(&amp;quot;Composing ♭♮♯♯♮♭♭♫♬♩♪...&amp;quot;)
    return &amp;quot;Final work: a beautiful song&amp;quot;
}
let paintTask = Task(name: &amp;quot;The Finest Paint Collection&amp;quot;, price: 2010000, proType: .Artist, isGroupTask: true) { peer in
    print(&amp;quot;\(peer.name) is doing the job...&amp;quot;)
    print(&amp;quot;Painting...&amp;quot;)
    return &amp;quot;Final work: Paint Work&amp;quot;
}

let mediator = CommandMediator()
let u1 = User(name: &amp;quot;The Queue &amp;quot;, mediator: mediator)
var u2 = User(name: &amp;quot;Michelangelo&amp;quot;, mediator: mediator, proType: .Artist)
let u3 = User(name: &amp;quot;Johannes&amp;quot;, mediator: mediator, proType: .Musician)
let u6 = User(name: &amp;quot;Ludwig&amp;quot;, mediator: mediator, proType: .Musician)
let u4 = User(name: &amp;quot;Eugène&amp;quot;, mediator: mediator, proType: .Artist)
let u5 = User(name: &amp;quot;Josh&amp;quot;, mediator: mediator, proType: .PartyPlanner)
let tasks = [partyTask, paintTask, musicTask, partyTask1]
for task in tasks {
    if task.isGroupTask {
        print(&amp;quot;\nSending a task called [\(task.name)]  that require a GROUP to finish....&amp;quot;)
        let groupResults = u1.sendTaskToGroupAndGetFinalWork(task)
        print(&amp;quot;The final work: \(groupResults.1)&amp;quot;)
    } else {
        print(&amp;quot;\nCreating a task called [\(task.name)] that require a single pro to finish ...&amp;quot;)
        let taskWithQuotes = u1.sendTaskAndGetTaskWithQuotes(task)
        print(taskWithQuotes)
        print(&amp;quot;Getting finished work and task....&amp;quot;)
        let taskFinishedByProAndWork = u1.choseProAndGetFinalWork(taskWithQuotes)
        print(&amp;quot;The final work: \(taskFinishedByProAndWork.1)&amp;quot;)
        u1.confirmWork((taskFinishedByProAndWork.0))
    }
}


let users = [u1, u2, u3, u4, u5, u6]
users.map{print(&amp;quot;\($0.description)&amp;quot;)}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

      
      &lt;p&gt;
        &lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/mediator.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1077&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/mediator.png&quot; alt=&quot;mediator&quot; width=&quot;746&quot; height=&quot;970&quot; /&gt;&lt;/a&gt;
      &lt;/p&gt;
      
      &lt;p&gt;
        Upon seeing the tasks, I can&amp;#8217;t help wonder: don&amp;#8217;t we all serve the pleasure of the queue?
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</content><author><name>Audrey</name></author><category term="Design Pattern" /><category term="Mediator" /><category term="Swift" /><summary>Artists paint, musicians compose, different jobs for different pros.  It’s not easy for a person to find a pro directly to do a job without some sort of agent in the middle, and even harder for a pro to find a client among all the people.</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 19: Flyweight</title><link href="http://audreyli.me/2015/07/17/a-design-pattern-story-in-swift-chapter-19-flyweight/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 19: Flyweight" /><published>2015-07-17T00:00:00-07:00</published><updated>2015-07-17T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/17/a-design-pattern-story-in-swift-chapter-19-flyweight</id><content type="html" xml:base="http://audreyli.me/2015/07/17/a-design-pattern-story-in-swift-chapter-19-flyweight/">&lt;div class=&quot;page&quot; title=&quot;Page 333&quot;&gt;
  &lt;div class=&quot;layoutArea&quot;&gt;
    &lt;div class=&quot;column&quot;&gt;
      &lt;p&gt;
        It&amp;#8217;s hard to get things done without a system to share and prioritize.  There are thousands of soldiers in the army, but only few of them are commanders. How can we quickly go through all the soldiers to find the commanders, their ranks, and how much power the army has together?
      &lt;/p&gt;
      
      &lt;blockquote&gt;
        &lt;p&gt;
          The flyweight pattern shares common data objects between multiple calling components.  It reduces the amount of memory needed to create the data objects required by the calling components and the amount of work required to create them. The impact of implementing the pattern increases with the number of calling components that share the data.  &lt;em&gt;&lt;a href=&quot;http://www.apress.com/9781484203958&quot;&gt;Design Pattern in Swift&lt;/a&gt; (The code is also referred by the book)&lt;/em&gt;
        &lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;struct Soldier{
    let name: String
    let id: Int
    var rank: Int
    var hashValue: Int { return name.hashValue }
}

func == (lhs: Soldier, rhs: Soldier) -&amp;gt; Bool {
    return lhs.id == rhs.id &amp;amp;&amp;amp; lhs.name == rhs.name
}

extension Dictionary {
    init(setupFunc: (() -&amp;gt; [(Key, Value)])){
        self.init()
        for item in setupFunc() {
            self[item.0] = item.1
        }
    }
}

protocol Flyweight {
    subscript(id: Int) -&amp;gt; Soldier? { get set }
    var totalPower: Int { get }
    var numberOfCommanders: Int { get }
}

//: There are thousands of soldiers in the army, most of which are lower level soldiers, but some are commanders with higher rank
//: extrinsic holds all soldiers, intrinsic represent those who are commanders (who&amp;#39;s rank has been updated to higher level).

class ArmyFlyweight: Flyweight {
    private let extrinsicArmy: [Int: Soldier]
    private var intrinsicArmy: [Int: Soldier]
    private let queue = dispatch_queue_create(&amp;quot;dataQ&amp;quot;, DISPATCH_QUEUE_CONCURRENT)
    
    init(soldiers: [Int: Soldier]) {
        self.extrinsicArmy = soldiers
        self.intrinsicArmy = [:]
    }
    
    subscript(id: Int) -&amp;gt; Soldier? {
        get {
            var result: Soldier?
            dispatch_sync(queue) { () -&amp;gt; Void in
                guard let soldier = self.intrinsicArmy[id] else {
                    result =  self.extrinsicArmy[id]
                    return
                }
                result = soldier
            }
            return result
        }
        set(newSoldier) {
            if newSoldier != nil {
                dispatch_sync(queue) { () -&amp;gt; Void in
                    self.intrinsicArmy[id] = newSoldier
                }
            }
        }
    }
    
    // each of the soldier&amp;#39;s power = rank * rank, initial rank for soliders is 0.
    var totalPower: Int {
        var result = 0
        dispatch_sync(queue) { () -&amp;gt; Void in
            result = self.intrinsicArmy.values.map{$0.rank * $0.rank}.reduce(0, combine: +)
        }
        return result
    }
    var numberOfCommanders: Int {
        var result = 0
        dispatch_sync(queue) { () -&amp;gt; Void in
            result = self.intrinsicArmy.count
        }
        return result
    }
    
}


class FlyweightFactory {
    static var numberOfSoldiers: Int = 10 {
        didSet {
            print(&amp;quot;Set the total number of soldiers to be \(numberOfSoldiers)&amp;quot;)
        }
    }
    class func createFlyweight() -&amp;gt; Flyweight {
        return ArmyFlyweight(soldiers: extrinsicArmy)
    }
    
    private class var extrinsicArmy: [Int: Soldier] {
        get {
            struct singletonWrapper {
                static let singleton = Dictionary&amp;amp;lt;Int, Soldier&amp;gt;(
                    setupFunc: { () in
                        var results:[(Int, Soldier)] = []
                        for i in 0..&amp;amp;lt;FlyweightFactory.numberOfSoldiers {
                            results.append(i, Soldier(name: &amp;quot;Sol#\(i)&amp;quot;, id: i, rank: 0))
                        }
                        return results
                    }
                    
                )
            }
            return singletonWrapper.singleton
        }
    }
}

class Army: CustomStringConvertible {
    private var soldiers: Flyweight
    init(){
        soldiers = FlyweightFactory.createFlyweight()
        print(&amp;quot;Army created!&amp;quot;)
    }
    var description: String {
        return &amp;quot;Total soldiers: \(FlyweightFactory.numberOfSoldiers). Total commanders: \(numberOfCommanders). Total Power:\(totalPower) \n&amp;quot;
    }
    func setRankBySoldier(var soldier: Soldier, newRank: Int){
        print(&amp;quot;Setting \(soldier.name)&amp;#39;s rank to be \(newRank)&amp;quot;)
        soldier.rank = newRank
        soldiers[soldier.id] = soldier
    }
    func getSoliderById(id: Int) -&amp;gt; Soldier? {
        return soldiers[id]
    }
    
    func setRankById(id: Int, newRank: Int){
        if var oldSoldier = soldiers[id] {
            print(&amp;quot;Setting \(oldSoldier.name)&amp;#39;s rank to be \(newRank)&amp;quot;)
            oldSoldier.rank = newRank
            soldiers[oldSoldier.id] = oldSoldier
        } else {
            print(&amp;quot;Failed! Trying to set rank to an unknown soldier whose id is \(id)&amp;quot;)
        }
    }
    func getCommanderNames() -&amp;gt; String {
        print(&amp;quot;Trying to get commanders&amp;#39; names&amp;quot;)
        guard let s = soldiers as? ArmyFlyweight else { return &amp;quot;Failed to get commanders&amp;#39; names&amp;quot; }
        return s.intrinsicArmy.values.map{$0.name}.reduce(&amp;quot;&amp;quot;){ $0 + &amp;quot;  &amp;quot; + $1}
    }
    var totalPower: Int { return soldiers.totalPower }
    var numberOfCommanders: Int { return soldiers.numberOfCommanders }
}

//: Testing
let totalNumberOfSoldiers = 20000
FlyweightFactory.numberOfSoldiers = totalNumberOfSoldiers
let army1 = Army()
print(army1.description)
let sol1 = army1.getSoliderById(2)

for i in 1...10 {
    army1.setRankById(Int(arc4random_uniform(24000)) , newRank: Int(arc4random_uniform(10)) + 1)
}

army1.setRankBySoldier(sol1!, newRank: 4)
print(army1.description)
print(army1.getCommanderNames())

print(&amp;quot;\n\n&amp;quot;)&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/Flyweight.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1074&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/Flyweight.png&quot; alt=&quot;Flyweight&quot; width=&quot;647&quot; height=&quot;326&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Design Patter" /><category term="Flyweight" /><category term="Swift" /><summary>It’s hard to get things done without a system to share and prioritize.  There are thousands of soldiers in the army, but only few of them are commanders. How can we quickly go through all the soldiers to find the commanders, their ranks, and how much power the army has together?</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 18: Visitor</title><link href="http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-18-visitor/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 18: Visitor" /><published>2015-07-15T00:00:00-07:00</published><updated>2015-07-15T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-18-visitor</id><content type="html" xml:base="http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-18-visitor/">&lt;p&gt;
  &lt;span&gt; It was Confucius who said isn&amp;#8217;t it great when friends visit from distant places. &lt;/span&gt;&lt;span&gt;子曰，&lt;/span&gt;&lt;span&gt; “&lt;/span&gt;&lt;span&gt;有朋自远方来，不亦乐乎&lt;/span&gt;&lt;span&gt;” &lt;/span&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
  &lt;span&gt;The visitor pattern allows new algorithms to operate on collections of heterogeneous objects without needing to modify or subclass the collection class. It&amp;#8217;s similar to the strategy pattern. &amp;#8212; &lt;em&gt;&lt;a href=&quot;http://www.apress.com/9781484203958&quot;&gt;Design Pattern in Swift&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;protocol Person {
    func accept(visitor: Visitor)
}

protocol Visitor {
    func visit(person: Dwarf)
    func visit(person: Maiden)
    func visit(person: Knight)
    
}

struct Dwarf: Person {
    let name: String
    let expectedAge: Int
    func accept(visitor: Visitor) {
        visitor.visit(self)
    }
}

struct Maiden: Person {
    let name: String
    let expectedAge: Int
    func accept(visitor: Visitor) {
        visitor.visit(self)
    }
}
struct Knight: Person {
    let name: String
    let expectedAge: Int
    let skillLevel: Int
    func accept(visitor: Visitor) {
        visitor.visit(self)
    }
}

struct People: Person {
    let group: [Person]
    func accept(visitor: Visitor) {
        group.map{ $0.accept(visitor) }
    }
}
//: A healthProVisitor can increase each person&amp;#39;s age by different amount of years
class HealthProVisitor: Visitor {
    var totalExpectedAgeOld = 0
    var totalExpectedAge = 0
    func visit(person: Dwarf) {
        totalExpectedAgeOld += person.expectedAge
        totalExpectedAge += person.expectedAge + 1
    }
    func visit(person: Knight) {
        totalExpectedAgeOld += person.expectedAge
        totalExpectedAge += person.expectedAge + 5
    }
    func visit(person: Maiden) {
        totalExpectedAgeOld += person.expectedAge
        totalExpectedAge += person.expectedAge + 10
    }
}

//: a prettyNameVisitor can form memoriable names for others to remember
class PrettyNameVisitor: Visitor {
    var names: [String] = []
    func visit(person: Maiden) {
        names.append(&amp;quot;Pretty Maiden \(person.name)&amp;quot;)
    }
    func visit(person: Knight) {
        names.append(&amp;quot;Knight \(person.name) with \(person.skillLevel) level of skills&amp;quot;)
    }
    func visit(person: Dwarf) {
        names.append(&amp;quot;A plain dwarf named \(person.name) &amp;quot;)
    }
}

//: Testing 
print(&amp;quot;Created a group of people Helen (32), Joe (99), Eleot(45)...&amp;quot;)
let people = People(group: [Maiden(name: &amp;quot;Helen&amp;quot;, expectedAge: 32),
        Dwarf(name: &amp;quot;Joe&amp;quot;, expectedAge: 99),
        Knight(name: &amp;quot;Eleot&amp;quot;, expectedAge: 32, skillLevel: 45)
    ])

let healthProVisitor = HealthProVisitor()
let prettyNameVisitor = PrettyNameVisitor()
print(&amp;quot;The healthProVisitor is visiting the group...&amp;quot;)
people.accept(healthProVisitor)
print(&amp;quot;Before visit, total expected age:\(healthProVisitor.totalExpectedAgeOld)&amp;quot;)
print(&amp;quot;After visit, total expected age:\(healthProVisitor.totalExpectedAge)\n&amp;quot;)
print(&amp;quot;The prettyNameVisitor is visiting the group...&amp;quot;)
people.accept(prettyNameVisitor)
print(&amp;quot;After visit, people&amp;#39;s names: \(prettyNameVisitor.names) \n&amp;quot;)


class InsuranceVisitor: Visitor {
    var salesRecord:[String: Bool] = [:]
    func visit(person: Dwarf) {
        salesRecord[person.name] = getQualification(person.expectedAge)
    }
    func visit(person: Knight) {
         salesRecord[person.name] = getQualification(person.expectedAge)
     }
    func visit(person: Maiden) {
         salesRecord[person.name] = getQualification(person.expectedAge)
    }
    
    private func getQualification(expectedAge: Int) -&amp;gt; Bool {
        return expectedAge &amp;gt; 45
    }
}


//: Testing
print(&amp;quot;A new visitor, the insurance guy! Let&amp;#39;s see what&amp;#39;s his sales record say after the visit&amp;quot;)
let insuranceVisitor = InsuranceVisitor()
people.accept(insuranceVisitor)
insuranceVisitor.salesRecord.map{
    print(&amp;quot;\($0.0), is eligiable for insurance?: \($0.1)&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/visitor.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1070&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/visitor.png&quot; alt=&quot;visitor&quot; width=&quot;792&quot; height=&quot;195&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Design Pattern" /><category term="Swift" /><category term="Visitor" /><summary>It was Confucius who said isn’t it great when friends visit from distant places. 子曰， “有朋自远方来，不亦乐乎”</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 17: Memento</title><link href="http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-17-memento/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 17: Memento" /><published>2015-07-15T00:00:00-07:00</published><updated>2015-07-15T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-17-memento</id><content type="html" xml:base="http://audreyli.me/2015/07/15/a-design-pattern-story-in-swift-chapter-17-memento/">&lt;p&gt;A good snapshot stops a beautiful moment from running away. At some point, we&amp;#8217;ll press the restore button and relive that moment again.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The memento pattern captures the complete state of an object into a memento that can be used to reset the object at a later date. It allows a complete reset of an object without the need to track and apply individual undo commands. –&lt;em&gt;  &lt;a href=&quot;http://www.apress.com/9781484203958&quot;&gt;Design Pattern in Swift&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;//: Just a sign to show the class / struct is a memento, nothing special
protocol Memento {
}

//: The originator can create and restore game state
protocol Originator {
    func createMemento() -&amp;gt; Memento
    func applyMemento(memento: Memento)
}

//: a game state entry
struct GameStateEntry {
    var level: Int
    var weapon: String
    var points: Int
}

//: A GameState memento, which contains all the information the CheckPoint needed to restore the state
struct GameMemento: Memento {
    private let entries: [Int: GameStateEntry]
    private let nextId: Int
    private let totalPoints: Int
    init(checkPoint: CheckPoint){
        self.entries = checkPoint.entries
        self.nextId = checkPoint.nextId
        self.totalPoints = checkPoint.totalPoints
    }
    func apply(checkPoint: CheckPoint) {
        print(&amp;quot;Restoring a game state to a checkpoint...&amp;quot;)
        checkPoint.nextId = nextId
        checkPoint.totalPoints = totalPoints
        checkPoint.entries = entries
    }
}
//: A CheckPoint can create and restore game state
class CheckPoint: Originator {
    private var entries: [Int: GameStateEntry] = [:]
    private var totalPoints: Int  = 0
    private var nextId: Int = 0
    
    func addGameStateEntry(level: Int, weapon: String, points: Int) {
        let entry = GameStateEntry(level: level, weapon: weapon, points: points)
        entries[nextId++] = entry
        totalPoints += points
    }
    
    func createMemento() -&amp;gt; Memento {
        return GameMemento(checkPoint: self)
    }
    
    func applyMemento(memento: Memento) {
        guard let m = memento as? GameMemento  else { return }
        m.apply(self)
    }
    
    func printCheckPoint() {
        print(&amp;quot;Printing checkPoint....&amp;quot;)
        entries.sort {$0.0 &amp;amp;lt; $1.0}
            .map {
                print(&amp;quot;Level: \($0.1.level)   Weapon: \($0.1.weapon)   Points: \($0.1.points) &amp;quot;)
        }
        print(&amp;quot;Total Points: \(totalPoints)\n&amp;quot;)
        
    }
}


//:Testing

let checkPoint = CheckPoint()
checkPoint.addGameStateEntry(0, weapon: &amp;quot;Fire Ball&amp;quot;, points: 20)
checkPoint.addGameStateEntry(1, weapon: &amp;quot;Flood&amp;quot;, points: 10)
checkPoint.printCheckPoint()
let memento = GameMemento(checkPoint: checkPoint)
checkPoint.addGameStateEntry(2, weapon: &amp;quot;Crusher&amp;quot;, points: 30)
checkPoint.addGameStateEntry(4, weapon: &amp;quot;Flower&amp;quot;, points: 30)
checkPoint.printCheckPoint()

checkPoint.applyMemento(memento)
checkPoint.printCheckPoint()&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/memento.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1065&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/memento.png&quot; alt=&quot;memento&quot; width=&quot;374&quot; height=&quot;286&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Design Pattern" /><category term="Memento" /><category term="Swift" /><summary>A good snapshot stops a beautiful moment from running away. At some point, we’ll press the restore button and relive that moment again.</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 16: Object Pool</title><link href="http://audreyli.me/2015/07/14/a-design-pattern-story-in-swift-chapter-16-object-pool/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 16: Object Pool" /><published>2015-07-14T00:00:00-07:00</published><updated>2015-07-14T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/14/a-design-pattern-story-in-swift-chapter-16-object-pool</id><content type="html" xml:base="http://audreyli.me/2015/07/14/a-design-pattern-story-in-swift-chapter-16-object-pool/">&lt;p&gt;
  &lt;span&gt;There is a MagicHouse where people can borrow magic objects. The house has a pool which manages the magic objects.&lt;/span&gt;
&lt;/p&gt;

&lt;div class=&quot;page&quot; title=&quot;Page 138&quot;&gt;
  &lt;div class=&quot;layoutArea&quot;&gt;
    &lt;div class=&quot;column&quot;&gt;
      &lt;blockquote&gt;
        &lt;p&gt;
          The object pool pattern manages a collection of reusable objects that are provided to calling components. A component obtains an object from the pool, uses it to perform work, and returns it to the pool so that it can be allocated to satisfy future requests. An object that has been allocated to a caller is not available for use by other components until it has been returned to the pool. &amp;#8212;&lt;em&gt;  &lt;a href=&quot;http://www.apress.com/9781484203958&quot;&gt;Design Pattern in Swift&lt;/a&gt;&lt;/em&gt;
        &lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;struct MagicObject {
    let name: String
    let serialNumber: Int
    var occupier: [String] = []
    var borrowedCount: Int = 0
}

//: a basic pool which allows getting and returning any objects.
class Pool&amp;amp;lt;T&amp;gt; {
    private var data = [T]()
    private let arrayQ = dispatch_queue_create(&amp;quot;arrayQ&amp;quot;, DISPATCH_QUEUE_SERIAL)
    private let semaphore: dispatch_semaphore_t
    
    init(items: [T]) {
        data.reserveCapacity(data.count)
        for item in items {
            data.append(item)
        }
        // create a counter semaphore for the available items in the pool
        semaphore = dispatch_semaphore_create(items.count)
    }
    
    func getFromPool() -&amp;gt; T? {
        var result: T?
        // the semaphore count is decreased each time when the wait is called. If the count is 0, the function will block
        if dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) == 0 {
            if data.count &amp;gt; 0 {
                dispatch_sync(arrayQ, { () -&amp;gt; Void in
                    result = self.data.removeAtIndex(0)
                })
            }
        }
        return result
    }
    
    func returnToPool(item: T){
        dispatch_sync(arrayQ, { () -&amp;gt; Void in
            self.data.append(item)
            // increase the counter by 1
            dispatch_semaphore_signal(self.semaphore)
        })
    }
}

extension Int {
    func times(action: (Int)-&amp;gt;()) {
        for i in 0..&amp;amp;lt;self {
            action(i)
        }
    }
}
class MagicHouse {
    private let pool: Pool&amp;amp;lt;MagicObject&amp;gt;
    static var sharedInstance = MagicHouse()
    static var magicDebtInfo:[(String, Int, String)] = []
    private init(){
        var magicObjects:[MagicObject] = []
        2.times{
            magicObjects.append(MagicObject(name: &amp;quot;Red Diamond&amp;quot;, serialNumber: $0, occupier: [], borrowedCount: 0))
        }
        3.times{
            magicObjects.append(MagicObject(name: &amp;quot;Blue Heart&amp;quot;, serialNumber: $0, occupier: [], borrowedCount: 0))
        }
        self.pool = Pool(items: magicObjects)
    }
    
    class func lendMagicObject(occupier: String) -&amp;gt; MagicObject? {
        var magicObject = sharedInstance.pool.getFromPool()
        if magicObject != nil {
            magicObject!.occupier.append(occupier)
            magicObject!.borrowedCount++
            magicDebtInfo.append((magicObject!.name, magicObject!.serialNumber, occupier))
            print(&amp;quot;\(occupier) is borrowing \(magicObject!.name) #\(magicObject!.serialNumber)&amp;quot;)
        }
        return magicObject
    }
    
    class func receiveMagicObject(obj: MagicObject) {
        magicDebtInfo = magicDebtInfo.filter{
            $0.0 != obj.name &amp;amp;&amp;amp; $0.1 != obj.serialNumber
        }
        sharedInstance.pool.returnToPool(obj)
        print(&amp;quot;\(obj.occupier.last!) returning \(obj.name) #\(obj.serialNumber)&amp;quot;)
    }
    
    class func printReport(){
        print(&amp;quot;\nShow Report: Magic House currently has \(sharedInstance.pool.data.count) magic object(s) in stock&amp;quot;)
        (sharedInstance.pool.data as [MagicObject]).map{
            print(&amp;quot;\($0.name) #\($0.serialNumber) \nBorrowed \($0.borrowedCount) time(s) by \($0.occupier)&amp;quot;)
        }
       
        if magicDebtInfo.count &amp;gt; 0 {
            print(&amp;quot;\nMagic Objects currently lent out:&amp;quot;)
            magicDebtInfo.map{
                print(&amp;quot;\($0.0) #\($0.1) by \($0.2)&amp;quot;)
            }
        }
    }
}

//: Testing
var queue = dispatch_queue_create(&amp;quot;workQ&amp;quot;, DISPATCH_QUEUE_CONCURRENT)
var group = dispatch_group_create()

print(&amp;quot;\n------Starting test...&amp;quot;)

for i in 1 ... 7 {
    dispatch_group_async(group, queue, {() in
        var obj = MagicHouse.lendMagicObject(&amp;quot;person #\(i)&amp;quot;)
        if obj != nil {
            NSThread.sleepForTimeInterval(Double(rand() % 3))
            MagicHouse.receiveMagicObject(obj!)
        }
    })
}

dispatch_group_wait(group, DISPATCH_TIME_FOREVER)
let m1 = MagicHouse.lendMagicObject(&amp;quot;William&amp;quot;)
let m3 = MagicHouse.lendMagicObject(&amp;quot;Tato&amp;quot;)
MagicHouse.printReport()&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/object-pool.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1060&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/object-pool.png&quot; alt=&quot;object-pool&quot; width=&quot;504&quot; height=&quot;523&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Design Pattern" /><category term="Object Pool" /><category term="Swift" /><summary>There is a MagicHouse where people can borrow magic objects. The house has a pool which manages the magic objects.</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 15: Bridge</title><link href="http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-15-bridge/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 15: Bridge" /><published>2015-07-13T00:00:00-07:00</published><updated>2015-07-13T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-15-bridge</id><content type="html" xml:base="http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-15-bridge/">&lt;p&gt;An IOT Bridge can handle different outgoing and incoming messages for the connected devices, regardless of the message format and the device types.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
  &lt;span&gt;The bridge pattern is used to separate the abstract elements of a class from the implementation details, providing the means to replace the implementation details without modifying the abstraction.&lt;/span&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;//: an IOT device can send two kinds of messages: IOTMessage which is the basic format, and EncryptIOTMessage which is encrypted message
protocol Message {
    var messageString: String { get }
    var contentToSend:String { get }
    func prepareMessage() -&amp;gt; String
}

struct IOTMessage: Message {
    var messageString: String
    var contentToSend: String {return prepareMessage()}
    func prepareMessage() -&amp;gt; String {
        return &amp;quot;Basic Message: \(messageString)&amp;quot;
    }
}
struct EncryptIOTMessage: Message {
    var messageString: String
    var contentToSend: String {return prepareMessage()}
    func prepareMessage() -&amp;gt; String {
        return &amp;quot;Encrypted Message: \(String(Array(messageString.characters.reverse())))&amp;quot;
    }
}


//: Since an IOT Device is connected, it can process outgoing and incoming messages
protocol IOTDevice: CustomStringConvertible {
    func processMessage(msg: Message, isIncomingMsg: Bool)
}

//: The base class for any kind of IOT devices
class Device: IOTDevice {
    var description: String { return &amp;quot;Basic Device returned, Error&amp;quot; }
    
    enum Devices {
        case WeigthScale
        case HumidityDetector
    }
    
    class func getDevice(deviceType: Devices) -&amp;gt; Device {
        switch deviceType {
        case .WeigthScale: return WeightScale()
        case .HumidityDetector: return HumidityDetector()
        }
    }
    func processMessage(msg: Message, isIncomingMsg: Bool) {
        fatalError(&amp;quot;Something wrong!&amp;quot;)
    }
}

//: A connected Weight Scale
class WeightScale: Device {
    override var description: String { return &amp;quot;Weight Scale&amp;quot; }
    override func processMessage(msg: Message, isIncomingMsg: Bool) {
        if isIncomingMsg {
            print(&amp;quot;Incoming message:[\(msg.contentToSend)]&amp;quot;)
        } else {
            print(&amp;quot;Outgoing message: [\(msg.contentToSend)]&amp;quot;)
        }
    }
}
//: A connected HumidityDetector
class HumidityDetector: Device {
    override var description: String { return &amp;quot;Humidity Detector&amp;quot; }
    override func processMessage(msg: Message, isIncomingMsg: Bool) {
        if isIncomingMsg {
            print(&amp;quot;Incoming message:[\(msg.contentToSend)]&amp;quot;)
        } else {
            print(&amp;quot;Outgoing message:[\(msg.contentToSend)]&amp;quot;)
        }
    }
}

//: Just a communication protocol, not important here
protocol IOTCommunication {
    var device:IOTDevice { get set }
    func processBridgeMessage(msg: Message, isIncomingMsg: Bool)
}

//: The bridge to handle the message processing of IOT devices
struct IOTBridge: IOTCommunication {
    var device: IOTDevice {
        didSet {
            print(&amp;quot;\nset bridge device to:\(device.description)&amp;quot;)
        }
    }

    internal func processBridgeMessage(msg: Message, isIncomingMsg: Bool) {
        device.processMessage(msg, isIncomingMsg: isIncomingMsg)
    }
    func sendMessage(msg: String, encrypted: Bool = false ){
        let msgStr = device.description + &amp;quot; &amp;quot; +  msg
        let iotMsg: Message = encrypted ? EncryptIOTMessage(messageString: msgStr) : IOTMessage(messageString: msgStr)
        processBridgeMessage(iotMsg, isIncomingMsg: false)
    }
    func receiveMessage(msg: String, encrypted: Bool = false) {
        let clearMsg = encrypted ? String(Array(msg.characters.reverse())) : msg
        var msgStr =  &amp;quot;\(device.description)  \(msg)&amp;quot;
        if encrypted {
            msgStr += &amp;quot;(decrypted: \(clearMsg))&amp;quot;
        }
        processBridgeMessage(IOTMessage(messageString: msgStr), isIncomingMsg: true)
    }

}

//: Testing 
print(&amp;quot;Create the IOT bridge and set the device to Weight Scale&amp;quot;)
var bridge = IOTBridge(device: WeightScale())
bridge.sendMessage(&amp;quot;120lb&amp;quot;)
bridge.receiveMessage(&amp;quot;History Weigth: 110 lb Oct. 20, 2014&amp;quot;)

bridge.device =  HumidityDetector()
bridge.sendMessage(&amp;quot;91%&amp;quot;)
bridge.receiveMessage(&amp;quot;History Humidity: 45% Aug. 30, 2014, 98% Dec. 21, 2014&amp;quot;)
bridge.sendMessage(&amp;quot;45% Aug. 30, 2014&amp;quot;, encrypted: true)
bridge.receiveMessage(&amp;quot;4102 ,03 .guA %54 rotceteD ytidimuH&amp;quot;, encrypted: true)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/bridge.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1056&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/bridge.png&quot; alt=&quot;bridge&quot; width=&quot;918&quot; height=&quot;137&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/chain-of-responsbility1.png&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Bridge" /><category term="Design Pattern" /><category term="Swift" /><summary>An IOT Bridge can handle different outgoing and incoming messages for the connected devices, regardless of the message format and the device types.</summary></entry><entry><title>A Design Pattern Story in Swift – Chapter 14: Chain Of Responsibility</title><link href="http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-14-chain-of-responsibility/" rel="alternate" type="text/html" title="A Design Pattern Story in Swift – Chapter 14: Chain Of Responsibility" /><published>2015-07-13T00:00:00-07:00</published><updated>2015-07-13T00:00:00-07:00</updated><id>http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-14-chain-of-responsibility</id><content type="html" xml:base="http://audreyli.me/2015/07/13/a-design-pattern-story-in-swift-chapter-14-chain-of-responsibility/">&lt;p&gt;
  &lt;span&gt;There is a dancing festival every year. Gods, Fairies and some other VIPs are in the guest list. There are also some unwelecomed walk-ins. Each of the guest type would have different host to receive and host them, except the walk-ins would have no hosts. &lt;/span&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
  &lt;span&gt; The chain of responsibility pattern is used to process varied requests, each of which may be dealt with by a different handler.&lt;/span&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;enum GuestType {
    case VIP
    case God
    case Fairy
    case Unwelcomed
}
&amp;lt;h2&amp;gt;
  &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;
&amp;lt;/h2&amp;gt;
struct Guest {
    let guestType: GuestType
    let name: String
}

class Host{
    var nextHost: Host?
    required init(){}
    
    func host(guest: Guest, handled: Bool = false) -&amp;gt; Bool {
        if nextHost != nil {
            return nextHost!.host(guest, handled: handled)
        } else if !handled {
            print(&amp;quot;End of the chain. No host available for \(guest.name)\n&amp;quot;)
        }
        return handled
    }
    
    class func createChain() -&amp;gt; Host?{
        let host = VIPHost()
        host.nextHost = GodHost()
        host.nextHost?.nextHost = FairyHost()
        return host
    }
}

class FairyHost: Host {
    override func host(guest: Guest, var handled: Bool) -&amp;gt; Bool {
        if guest.guestType == .Fairy {
            print(&amp;quot;\(guest.name) is handled by FairyHost\n&amp;quot;)
            handled = true
        }
        return super.host(guest, handled: handled)
    }
}

class GodHost: Host {
    override func host(guest: Guest, var handled: Bool) -&amp;gt; Bool {
        if guest.guestType == .God {
            print(&amp;quot;\(guest.name) is handled by GodHost\n&amp;quot;)
            handled = true
        }
        return super.host(guest, handled: handled)
    }
}

class VIPHost: Host {
    var totalGuests = 0
    var vipGuests = 0
    override func host(guest: Guest, var handled: Bool) -&amp;gt; Bool {
        totalGuests++
        if guest.guestType == .VIP {
            print(&amp;quot;\(guest.name) is handled by VIPHost&amp;quot;)
            handled = true
            vipGuests++
            print(&amp;quot;Currently \(vipGuests) VIP out of \(totalGuests) guests\n&amp;quot;)
        }
        return super.host(guest, handled: handled)
    }
}

//: Testing 
let guests = [Guest(guestType: .Fairy, name: &amp;quot;Tinkle Fairy&amp;quot;),
              Guest(guestType: .God, name: &amp;quot;God of Thunder&amp;quot;),
              Guest(guestType: .VIP, name: &amp;quot;VIP Tor&amp;quot;),
              Guest(guestType: .Unwelcomed, name: &amp;quot;Satan&amp;quot;),
              Guest(guestType: .VIP, name: &amp;quot;VIP Helen&amp;quot;)]


if let hostChain = Host.createChain() {
    for guest in guests {
        hostChain.host(guest)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/wp-content/uploads/2015/07/chain-of-responsbility.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1049&quot; src=&quot;/assets/images/wp-content/uploads/2015/07/chain-of-responsbility.png&quot; alt=&quot;chain-of-responsbility&quot; width=&quot;326&quot; height=&quot;169&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name>Audrey</name></author><category term="Chain Of Responsibility" /><category term="Design Pattern" /><category term="Swift" /><summary>There is a dancing festival every year. Gods, Fairies and some other VIPs are in the guest list. There are also some unwelecomed walk-ins. Each of the guest type would have different host to receive and host them, except the walk-ins would have no hosts.</summary></entry></feed>
